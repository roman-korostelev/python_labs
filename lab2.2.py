"""Изучить и реализовать шаблон проектирования Singleton, который можно применять на произвольный класс.
Разработать, как минимум, ДВА различных (технически) способа решения задачи."""
def first_decorator(cls):
    """Реализация шаблона Singleton через декорирющую функцию, возвращающую класс.
     В самом классе сделана проверка на наличие экземпляра класса. Для каждого класса создается отдельный экземпляр
     декорирующего класса. Основной плюс данного метода в том, что он позволяет напрямую вызывать методы декорируемого
     класса, чем не могла бы похвастаться подобная реализация через обычную декорирующую функцию без класса-обертки.
     Ну и как следствие тестировать данный код будет в разу проще."""
    class _SingletonWrapper:
        def __init__(self, cls):
            self.__wrapped__ = cls
            self._instance = None

        def __call__(self, *args, **kwargs):
            if self._instance is None:
                self._instance = self.__wrapped__(*args, **kwargs)
            return self._instance
    return _SingletonWrapper(cls)


@first_decorator
class Dog:
    def __init__(self, n):
        print("Woof!"*n)
        self.n = n


class SingletonMeta(type):
    """Реализация шаблона Singleton через метакласс. В классе хранится словарь классов, в которых был создан хотя бы
    один экземпляр. Основной плюс данного метода в том, что мы не создаем для каждого класса новый класс-обертку, что
    безусловно не может не радовать. Все хранится в одном месте. Для хранения классов был выбрано именно словарь, по
    причине его структуры. В питоне словарь построен на хеш-таблицах, сложность поиска элемента в которых в среднем
    случае О(1), что значительно лучше обычного списка. Так же это было отличным случаем для того, чтобы использовать
    метаклассы. Подытожив, могу сказать, что обе реализации имеют место быть и использовать их можно ситуативно либо
    по настроению."""
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            instance = super().__call__(*args, **kwargs)
            cls._instances[cls] = instance
        return cls._instances[cls]


class Cat(metaclass=SingletonMeta):
    def __init__(self, color):
        print("Meow")
        self.color = color


a = Dog(23)
b = Dog(22)
print(a is b)
print()

a = Cat("White")
b = Cat("Black")
print(a is b)
